# `getPath` 동작 원리 정리

## `getPath` 함수는 2차원 배열로 정의한 값을 경로를 계산

## 함수 시그니처

```ts
type Step = { row: number; col: number };

function getPath(startIndex: number, ladder: number[][]): Step[];
```

## `getPath`를 알기 전에 작은 그림으로 `ladder` 이해하기

예를 들어 `ladder`는 아래와 같은 값처럼 주어진다.
**각 1차원 배열은 한 행(row)**를 의미한다.

```ts
const ladder = [
  [1], // 0 번째 행
  [0, 3], // 1 번째 행
  [2], // 2 번째 행
];
```

그리고 그림으로 표현하면,

```
col   0   1   2   3   4
      |   |   |   |   |
row0  |   |---|   |   |   0 번째 행
row1  |---|   |   |---|   1 번째 행
row2  |   |   |---|   |   2 번째 행

```

그리고 각 행 안의 숫자(ex. `[1]`)들은 그 행에 있는 **가로줄의 시작 위치(col)** 들이다.  
즉, `0`번째 행의 `[1]`은 가로줄의 시작 위치가 `0`번째 행에서 `col 1`을 의미한다.

가로줄은 항상 바로 오른쪽 한 칸만 연결한다.  
즉, 시작 위치에서 `+1`한 위치까지 이어진다고 생각하면 된다.  
→ `col`이 주어지면 `col + 1`까지 연결된다.

---

### 🔎 예시 1) 0번째 행이 `[1]`인 경우

> 0번째 행에 `[1]`이 있으므로, 그 행에서 `col 1`과 `col 2`가 연결된다.

```
col   0   1   2   3   4
      |   |   |   |   |
row0  |   |───|   |   |   (col 1 ↔ col 2 연결)

```

### 🔎 예시 2) 1번째 행이 [0, 3]인 경우

> 1번째 행이 `[0, 3]`이므로,
> `col 0`과 `col 1`, `col 3`과 `col 4`에 각각 가로줄이 생긴다.

```
col   0   1   2   3   4
      |   |   |   |   |
row1  |───|   |   |───|   (col 0 ↔ col 1, col 3 ↔ col 4 연결)

```

---------------------아래 내용 수정 예정---------------------

## 입력 매개변수

### 1) `startIndex` (시작 열 인덱스)

- 맨 위에서 몇 번째 세로줄(col)에서 출발하느냐를 의미
- 예: 세로줄이 4개면 `col`은 `0, 1, 2, 3` 중 하나

---

### 2) `ladder` (행(row) 단위 데이터)

`ladder`는 사다리에서 위에서 아래로 내려갈 때,  
**각 높이(row)마다 어느 열(col)에서 가로줄이 연결되어 있는지**를 표현한 2차원 배열입니다.

### 정의

- `ladder[rowIdx]`는 해당 높이(row)에서 **가로줄이 시작되는 열(col) 인덱스들의 목록**입니다.
- 숫자 `x`는 **`x`와 `x+1`이 가로줄로 연결되어 있다**는 뜻입니다.

### 설명

사다리를 위에서 아래로 내려가면서,  
각 row마다 “어디에 가로줄이 걸려 있는지”를 배열로 표현한 구조입니다.  
가로줄은 항상 왼쪽(col)과 오른쪽(col+1)을 연결하므로,  
**시작 위치인 왼쪽 col만 저장합니다.**

#### 왜 “시작 열”만 저장하나요?

가로줄이 항상 “왼쪽(col) ↔ 오른쪽(col+1)” 형태라서,  
**시작점 `x`만 알면 연결이 `x <-> x+1`로 결정**되기 때문입니다.

---

## “행(row) 기준”이란?

사다리를 위에서 아래로 내려갈 때, 우리는 **각 높이(row)** 에서:

- “여기 가로줄이 어디에 있지?”를 확인하고,
- 있다면 좌/우로 한 칸 이동하고,
- 다음 row로 내려갑니다.

따라서 데이터도 “row 순서대로 확인하기 쉬운 형태”인:

- `ladder[0]` = 0번째 row의 가로줄 정보
- `ladder[1]` = 1번째 row의 가로줄 정보
- ...

로 되어 있는 것입니다.

---

---

## 핵심 규칙 (한 줄 요약)

각 행(row)을 내려갈 때마다 현재 열 `col`에 대해:

1. `row.includes(col)`이면, **현재 열에서 오른쪽으로 연결된 가로줄**이 있으므로 `col += 1`
2. 아니면 `row.includes(col - 1)`이면, **왼쪽 열에서 현재 열로 연결된 가로줄**이 있으므로 `col -= 1`
3. 둘 다 아니면 `col` 유지

그리고 각 행을 지난 뒤 `{ row: rowIdx, col }`을 경로에 기록합니다.

---

## 코드(참고)

```ts
const getPath = (startIndex: number, ladder: number[][]): Step[] => {
  let col = startIndex;
  const path: Step[] = [{ row: -1, col }];

  ladder.forEach((row, rowIdx) => {
    if (row.includes(col)) col += 1;
    else if (row.includes(col - 1)) col -= 1;
    path.push({ row: rowIdx, col });
  });

  return path;
};
```

---

## 예시 1: 4열(column) 사다리

열 인덱스: `0, 1, 2, 3`

가로줄 규칙: `x`가 있으면 `x`와 `x+1`을 연결합니다.

### 사다리 데이터

```ts
const ladder = [
  [1], // row 0: (1 <-> 2) 연결
  [], // row 1: 없음
  [0], // row 2: (0 <-> 1) 연결
  [2], // row 3: (2 <-> 3) 연결
];
```

시각화(개념)

- row 0: `1─2`
- row 2: `0─1`
- row 3: `2─3`

---

### 케이스 A) startIndex = 1

초기: `col = 1`

- row 0: `row.includes(1)` ✅ → `col = 2`
- row 1: `[]` → 유지 → `col = 2`
- row 2: `row.includes(2)` ❌, `row.includes(1)`? (`col-1=1`) ❌ → `col = 2`
- row 3: `row.includes(2)` ✅ → `col = 3`

반환되는 path:

```ts
[
  { row: -1, col: 1 },
  { row: 0, col: 2 },
  { row: 1, col: 2 },
  { row: 2, col: 2 },
  { row: 3, col: 3 },
];
```

---

### 케이스 B) startIndex = 2

초기: `col = 2`

- row 0: `row.includes(2)` ❌, `row.includes(1)`? (`col-1=1`) ✅ → `col = 1`
  - 의미: row 0에 (1 <-> 2) 가로줄이 있으니, 2에서 내려오면 1로 넘어감
- row 1: 없음 → `col = 1`
- row 2: `row.includes(1)` ❌, `row.includes(0)`? (`col-1=0`) ✅ → `col = 0`
- row 3: `row.includes(0)` ❌, `row.includes(-1)` ❌ → `col = 0`

path:

```ts
[
  { row: -1, col: 2 },
  { row: 0, col: 1 },
  { row: 1, col: 1 },
  { row: 2, col: 0 },
  { row: 3, col: 0 },
];
```

---

## 예시 2: 왜 `col-1`을 검사하는지

`row.includes(col)`은 **현재 col에서 오른쪽(col+1)으로 가는 가로줄**이 있다는 뜻입니다.

하지만 현재 col이 가로줄의 **오른쪽 끝**일 수도 있어요.  
예를 들어 row에 `[1]`이 있고 현재 `col = 2`라면:

- `row.includes(2)`는 false (2에서 시작하는 가로줄은 없음)
- 하지만 (1 <-> 2) 연결은 존재하므로 **2는 그 가로줄의 오른쪽 끝**
- 따라서 `row.includes(2 - 1 = 1)`을 확인해 true면 **왼쪽(1)로 이동**해야 합니다 → `col -= 1`

---

## 데이터 형태 주의사항

이 구현은 `ladder`가 **행(row) 기준**이라는 전제를 둡니다.

- `ladder[rowIdx] = [가로줄 시작 col들...]`

만약 데이터가 **열(column) 기준**으로 내려온다면(예: `ladder[col] = [row들...]`),
`getPath`는 그대로 쓰면 잘못된 경로를 계산합니다.  
이 경우에는 데이터를 **row 기준으로 변환**하거나, 로직을 데이터 형태에 맞게 바꿔야 합니다.

---

## (추가) “한 row에 여러 가로줄”은 어떻게 표현하나요?

예를 들어 row 0에 가로줄이 두 개 있다고 해볼게요:

- (0 <-> 1) 연결 → 시작 열 0
- (2 <-> 3) 연결 → 시작 열 2

그럼 `ladder[0]`은 이렇게 됩니다:

```ts
const ladder = [
  [0, 2], // row 0: (0<->1), (2<->3)
  ...
];
```

이때 `getPath`는 현재 `col`이 0이면 오른쪽으로, 1이면 왼쪽으로, 2이면 오른쪽으로, 3이면 왼쪽으로 이동할 수 있습니다.

> 보통 사다리 게임에서는 같은 row에서 가로줄이 “붙어있게(예: 0과 1이 동시에)” 생기지 않도록 제약을 두는 경우가 많습니다.  
> (예: `[0, 1]`처럼 연속 시작점은 금지)  
> 이런 제약이 없다면 경로가 애매해질 수 있으니 데이터 생성 단계에서 막아두는 게 안전합니다.

---

## 테스트용 스니펫

```ts
const ladder = [[1], [], [0], [2]];

console.log(getPath(1, ladder));
console.log(getPath(2, ladder));
```

---

## 요약

- `ladder`는 **row(높이)별 가로줄 정보**이며, 각 row에는 **가로줄의 시작 열 인덱스**들이 들어 있습니다.
- 시작 열 `x`는 항상 `(x <-> x+1)` 연결을 의미합니다.
- `getPath`는 row를 위에서 아래로 순회하면서 현재 `col`이 가로줄의 왼쪽 끝이면 오른쪽으로, 오른쪽 끝이면 왼쪽으로 이동합니다.
- 반환값 `path`는 애니메이션/이동 계산에 바로 사용할 수 있는 `{ row, col }` 기록입니다.
